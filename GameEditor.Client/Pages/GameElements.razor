@page "/editor"

@using GameEditor.Client.Components.Dialogs
@using GameEditor.Client.Components.FormFields
@using GameModel.Models
@using GameModel.Helpers
@inject IGamePackService GamePackService
@inject IDialogService DialogService
@inject IGamePackService GamePackService

<h3>GameElements</h3>

<MudTabs>

    <MudTabPanel Text="Scenes">
        <GameElementsTable Title="Scenes"
            Items="GamePackService.Current!.Scenes.Values"
            ShowCreate="true"
            CreateText="New Scene"
            OnCreate="NewScene"
            OnEdit="EditScene"
            OnDelete="DeleteScene" />



    </MudTabPanel>

    <MudTabPanel Text="Items">
        <GameElementsTable Title="Items"
            Items="GamePackService.Current!.Items.Values"
            ShowCreate="true"
            CreateText="New Item"
            OnCreate="NewItem"
            OnEdit="EditItem"
            OnDelete="DeleteItem" />

    </MudTabPanel>

    <MudTabPanel Text="NPCs">
        <GameElementsTable Title="NPCs"
            Items="GamePackService.Current!.Npcs.Values"
            ShowCreate="true"
            CreateText="New NPC"
            OnCreate="NewNpc"
            OnEdit="EditNpc"
            OnDelete="DeleteNpc" />

    </MudTabPanel>

</MudTabs>


@code {


    private async Task EditElementAsync<T>(T? element) where T : class, IGameElement
    {

        var title = element != null ? $"Edit '{element.Name}'" : $"Add {nameof(T)}";
        var options = new DialogOptions { CloseButton = true, MaxWidth = MaxWidth.ExtraExtraLarge, FullWidth = true };

        if (element == null)
        {
        }

        DialogParameters dialogParams = new()
        {
            { nameof(GameElementDialog<T>.Value), element},
        };

        var dialog = await DialogService.ShowAsync<GameElementDialog<T>>(title, dialogParams, options);
        var result = await dialog.Result;

        if (result == null || result.Canceled || result.Data is not T updated) return;
        CopyEditableFields(element, updated);

        await GamePackService.UpdateCurrentAsync();
        StateHasChanged();

    }

    private static void CopyEditableFields<T>(T target, T source)
    where T : IGameElement
    {
        target.Name = source.Name;
        target.Description = source.Description;
        target.IsVisible = source.IsVisible;
        target.States = source.States.DeepClone();
        target.Attributes = source.Attributes.DeepClone();
        target.Properties = source.Properties.DeepClone();
        target.Flags = source.Flags.DeepClone();

        if (target is Scene ts && source is Scene ss)
        {
            ts.MapLocation = ss.MapLocation.DeepClone();
            // Don’t overwrite exits
        }
    }


    private async Task NewScene()
    {
        await EditElementAsync<Scene>(new Scene());

    }


    private async Task EditScene(GameModel.Models.IGameElement args)
    {

        await EditElementAsync<Scene>(args as Scene ?? throw new ArgumentException("Invalid element type"));
 
    }


    private void DeleteScene(GameModel.Models.IGameElement args)
    {
        throw new NotImplementedException();
    }


    private void NewItem()
    {
        throw new NotImplementedException();
    }
    private void EditItem(GameModel.Models.IGameElement args)
    {
        throw new NotImplementedException();
    }
    private void DeleteItem(GameModel.Models.IGameElement args)
    {
        throw new NotImplementedException();
    }
    
    
    private void NewNpc()
    {
        throw new NotImplementedException();
    }
    private void EditNpc(GameModel.Models.IGameElement args)
    {
        throw new NotImplementedException();
    }
    private void DeleteNpc(GameModel.Models.IGameElement args)
    {
        throw new NotImplementedException();
    }

}


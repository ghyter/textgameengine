@page "/map"
@using Blazor.Diagrams
@using Blazor.Diagrams.Components
@using Blazor.Diagrams.Components.Widgets
@using Blazor.Diagrams.Core.Geometry
@using Blazor.Diagrams.Core.Models
@using Blazor.Diagrams.Core.PathGenerators
@using Blazor.Diagrams.Core.Routers
@using Blazor.Diagrams.Options
@using GameEditor.Client.Components.MapNodes
@using GameEditor.Client.Model.Nodes
@using GameModel.Models
@using GameModel.Models.Enums
@using GameModel.Session
@using Point = Blazor.Diagrams.Core.Geometry.Point
@inject IGamePackService GamePackService
@* @inject ISnackbar snackbar *@

<h3>Game Editor</h3>

@if (Diagram is not null)
{
    <div class="diagram-container">
        <CascadingValue Value="Diagram" IsFixed="true">
            <DiagramCanvas>
                <Widgets>
                    <GridWidget Size="30" Mode="GridMode.Line" BackgroundColor="white" />
                </Widgets>
            </DiagramCanvas>
        </CascadingValue>
    </div>
}




@code {
    private BlazorDiagram Diagram { get; set; } = null!;
    private Dictionary<string, SceneNode> _nodemap { get; set; } = [];

    private int xOffset = 300;
    private int yOffset = 200;

    protected override void OnInitialized()
    {
        // Create the diagram BEFORE the first render
        var options = new BlazorDiagramOptions
            {
                AllowMultiSelection = true,
                Zoom = { Enabled = true },
                Links =
            {
                // If you need these, re-add:
                DefaultRouter = new NormalRouter(),
                DefaultPathGenerator = new SmoothPathGenerator()
            },
            };

        Diagram = new BlazorDiagram(options);
        Diagram.RegisterComponent<SceneNode, SceneWidget>();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender || Diagram is null) return;

        if (GamePackService.Current is null || GamePackService.Current.Scenes.Count == 0)
        {
            //snackbar.Add("Current Game does not have any scenes", Severity.Error);
            return;
        }

        var startingLocation = GamePackService.Current.Player.StartingLocation;

        var playerLocation = GamePackService.Current.Scenes.Where(p=> p.Key == startingLocation).FirstOrDefault();
        

        await AddLinks(playerLocation.Value,new Point(200, 200));
        // OPTIONAL: center node after container is ready

        await Task.Yield();
        Diagram.Refresh();
        Diagram.ZoomToFit();
    }


    private async Task AddLinks(Scene element, Point position){

        if (!_nodemap.TryGetValue(element?.Id ?? string.Empty,out var nodemodel)){

            var node = new SceneNode(element!.Id,position, element)
            {
                Title = element.Name,              
            };
            
            _nodemap[element.Id] = node;
            Diagram.Nodes.Add(node);

            foreach (var e in element.Exits)
            {

                PortAlignment? portdirection =  e.Direction switch{
                    ExitDirections.North => PortAlignment.Top,
                    ExitDirections.NorthEast => PortAlignment.TopRight,
                    ExitDirections.East => PortAlignment.Right,
                    ExitDirections.SouthEast => PortAlignment.BottomRight,
                    ExitDirections.South => PortAlignment.Bottom,
                    ExitDirections.SouthWest => PortAlignment.BottomLeft,
                    ExitDirections.West => PortAlignment.Left,
                    ExitDirections.NorthWest => PortAlignment.TopLeft,
                    _=> null
                };
                if (portdirection != null){
                    node.AddPort(new PortModel(node,portdirection.Value));
                }
                if ( GamePackService.Current!.Scenes.TryGetValue(e.TargetId, out var targetElement)){
                    var offset = e.Direction switch
                    {
                        ExitDirections.North => new Point(position.X, position.Y - yOffset),
                        ExitDirections.NorthEast => new Point(position.X + xOffset, position.Y - yOffset),
                        ExitDirections.East => new Point(position.X + xOffset, position.Y),
                        ExitDirections.SouthEast => new Point(position.X + xOffset, position.Y + yOffset),
                        ExitDirections.South => new Point(position.X, position.Y + yOffset),
                        ExitDirections.SouthWest => new Point(position.X - xOffset, position.Y + yOffset),
                        ExitDirections.West => new Point(position.X - xOffset, position.Y),
                        ExitDirections.NorthWest => new Point(position.X - xOffset, position.Y - yOffset),
                        _ => new Point(1,1)
                    };

                    await AddLinks(targetElement,offset);
                }
            };

        }

    }





    private async Task CenterOnViewport(NodeModel node)
    {
        // Let JS interop inside the library finalize measurements if needed
        await Task.Yield();

        if (Diagram?.Container is null) return;

        var cx = Diagram.Container.Width / 2.0;
        var cy = Diagram.Container.Height / 2.0;

        var zoom = Diagram.Zoom;
        var pan  = Diagram.Pan; // screen-space translation

        // Convert viewport center (screen) -> diagram coords
        var worldX = (cx - pan.X) / zoom;
        var worldY = (cy - pan.Y) / zoom;

        node.Position = new Point(worldX - node.Size?.Width ?? 100 / 2.0, worldY - node.Size?.Height ?? 100 / 2.0);
        Diagram.Refresh();
    }
}

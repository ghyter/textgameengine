@* DictEditor.razor *@
@typeparam TValue

@using MudBlazor
@inherits ComponentBase

<MudStack Spacing="2">
    <MudStack Row AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
        @if (!string.IsNullOrEmpty(Title))
        {
            <MudText Typo="Typo.h6">@Title</MudText>
        }
        <MudButton StartIcon="@Icons.Material.Filled.Add" OnClick="AddRow">Add</MudButton>
    </MudStack>

    @if (!string.IsNullOrWhiteSpace(Help))
    {
        <MudText Typo="Typo.body2" Class="text-secondary">@Help</MudText>
    }

    
    <MudTable T="string" Items="_rows.Keys.ToList()" Dense="true" Elevation="0">
        <HeaderContent>
            <MudTh style="width:30%">Key</MudTh>
            <MudTh>Value</MudTh>
            <MudTh style="width:56px"></MudTh>
        </HeaderContent>

        <RowTemplate>
            <MudTd>
                <MudTextField @bind-Value="_editKeys[context]"
                              Immediate="true"
                              Placeholder="key"
                              Pattern="@KeyPattern"
                              HelperText="@KeyHelperText"
                              OnBlur="@(() => RenameKey(context, _editKeys[context]))" />
            </MudTd>

            <MudTd>
                @RenderValueCell(context)
            </MudTd>

            <MudTd>
                <MudIconButton Icon="@Icons.Material.Filled.Delete"
                               Color="Color.Error"
                               OnClick="@(() => RemoveRow(context))" />
            </MudTd>
        </RowTemplate>
    </MudTable>
</MudStack>

@code {
    // ── Public API ────────────────────────────────────────────────────────────────
    [Parameter] public string Title { get; set; } = "Dictionary";
    [Parameter] public string? Help { get; set; }

    [Parameter] public string KeyPattern { get; set; } = "^[a-z0-9-]+$";
    [Parameter] public string KeyHelperText { get; set; } = "Lowercase letters, digits, hyphens only.";

    [Parameter] public Dictionary<string, TValue> Values { get; set; } = new();
    [Parameter] public EventCallback<Dictionary<string, TValue>> ValuesChanged { get; set; }

    // Optional: override the default value used when clicking Add
    [Parameter] public TValue? NewValueDefault { get; set; }

    // ── Internals ────────────────────────────────────────────────────────────────
    private Dictionary<string, TValue> _rows = new();
    private Dictionary<string, string> _editKeys = new();

    protected override void OnParametersSet()
    {
        // shallow copy so edits don't mutate parent until we push
        _rows = Values?.ToDictionary(kv => kv.Key, kv => kv.Value)!;
        _editKeys = _rows.Keys.ToDictionary(k => k, k => k);
    }

    private void AddRow()
    {
        var key = GenerateKey("new-key");
        _rows[key] = NewValueDefault is not null ? NewValueDefault
                     : typeof(TValue) == typeof(string) ? (TValue)(object)string.Empty
                     : typeof(TValue) == typeof(int) ? (TValue)(object)0
                     : typeof(TValue) == typeof(bool) ? (TValue)(object)false
                     : default!;
        _editKeys[key] = key;
        Push();
    }

    private void RemoveRow(string key)
    {
        if (_rows.Remove(key))
        {
            _editKeys.Remove(key);
            Push();
        }
    }

    private void RenameKey(string oldKey, string? newKey)
    {
        newKey ??= "";
        newKey = newKey.Trim();
        if (string.IsNullOrEmpty(newKey) || newKey == oldKey) { _editKeys[oldKey] = oldKey; return; }
        if (!System.Text.RegularExpressions.Regex.IsMatch(newKey, KeyPattern)) { _editKeys[oldKey] = oldKey; return; }
        if (_rows.ContainsKey(newKey)) { _editKeys[oldKey] = oldKey; return; }

        var val = _rows[oldKey];
        _rows.Remove(oldKey);
        _rows[newKey] = val;

        var edited = _editKeys[oldKey];
        _editKeys.Remove(oldKey);
        _editKeys[newKey] = edited == oldKey ? newKey : edited;

        Push();
    }

    private async void Push()
    {
        // emit a fresh copy for @bind-Values
        await ValuesChanged.InvokeAsync(_rows.ToDictionary(k => k.Key, v => v.Value));
        StateHasChanged();
    }

    private string GenerateKey(string baseKey)
    {
        var existing = new HashSet<string>(_rows.Keys);
        var key = baseKey; var i = 1;
        while (existing.Contains(key)) key = $"{baseKey}-{i++}";
        return key;
    }

    // ── Value cell renderer (auto-picks control by TValue) ───────────────────────
    private RenderFragment RenderValueCell(string key) => builder =>
    {
        var seq = 0;

        if (typeof(TValue) == typeof(string))
        {
            builder.OpenComponent(seq++, typeof(MudTextField<string>));
            builder.AddAttribute(seq++, "Value", (string)(object?)_rows[key]!);
            builder.AddAttribute(seq++, "ValueChanged",
            EventCallback.Factory.Create<string>(this, v => { _rows[key] = (TValue)(object)v; Push(); }));
            builder.AddAttribute(seq++, "Immediate", true);
            builder.AddAttribute(seq++, "Placeholder", "text…");
            builder.CloseComponent();
            return;
        }

        if (typeof(TValue) == typeof(int))
        {
            builder.OpenComponent(seq++, typeof(MudNumericField<int>));
            builder.AddAttribute(seq++, "Value", (int)(object?)_rows[key]!);
            builder.AddAttribute(seq++, "ValueChanged",
            EventCallback.Factory.Create<int>(this, v => { _rows[key] = (TValue)(object)v; Push(); }));
            builder.AddAttribute(seq++, "Immediate", true);
            builder.CloseComponent();
            return;
        }

        if (typeof(TValue) == typeof(bool))
        {
            // MudSwitch uses Checked/CheckedChanged
            builder.OpenComponent(seq++, typeof(MudSwitch<bool>));
            builder.AddAttribute(seq++, "Checked", (bool)(object?)_rows[key]!);
            builder.AddAttribute(seq++, "CheckedChanged",
            EventCallback.Factory.Create<bool>(this, v => { _rows[key] = (TValue)(object)v; Push(); }));
            builder.AddAttribute(seq++, "Color", Color.Primary);
            builder.CloseComponent();
            return;
        }

        // Fallback (unsupported type)
        builder.OpenComponent(seq++, typeof(MudText));
        builder.AddAttribute(seq++, "ChildContent", (RenderFragment)(b =>
      {
          b.AddContent(0, $"Unsupported type {typeof(TValue).Name}");
      }));
        builder.CloseComponent();
    };
}
